
\documentclass{article}
\usepackage{lipsum,amsmath, amssymb, amsthm, tikz}

\title{Specifying and Verifying a Carry-Look-Ahead Adder for the Lambda32 Processor}
\author{Amjad Ali}

\newtheorem{lemma}{Lemma}


\begin{document}
\maketitle

\begin{abstract}
\lipsum[1]
\end{abstract}

\section{Introduction}
\lipsum[1-2] 

\section{Preliminaries}
In this section, we introduce the fundamental building blocks that are essential throughout our proof. Let us begin by defining a carry-out and sum output of a typical 1-bit full-adder. In a standard 1-bit full-adder architecture, there are three inputs: a and b represent the primary operands, and c serves as the carry-in.

\noindent \textbf{Definition 2.1} Suppose $a$, $b$, and $c$ are propositions. Then, carry-out and sum are denoted by the following predicates:

\begin{enumerate}
	\item $CO(a, b, c) :\equiv (a \land b) \lor (a \land c) \lor (b \land c)$
	
	\item $S(a, b, c) :\equiv 
	(a \land b \land c) \lor 
	(a \land \lnot b \land \lnot c) \lor 
	(\lnot a \land b \land \lnot c) \lor
	(\lnot a \land \lnot b \land c) $
\end{enumerate}

In a standard 1-bit full-adder, the carry-out is  $True$ when two, or all, of its operands are $True$. Further scrutiny of our minimal definition of $CO$ shows it conforms with this behavior:

\noindent \textbf{Lemma 2.1}  $ (\forall a, b, c \in \{T, F\}) \: CO(a, b, c) \iff  (\lnot a \land b \land c) \lor (a \land \lnot b \land c) \lor \\ (a \land b \land \lnot c) \lor  (a \land b \land c)$ 

\begin{proof}
	\begin{align*}
		(1) &  \quad (\lnot a \land b \land c) \lor (a \land \lnot b \land c) \lor (a \land b \land \lnot c) \lor (a \land b \land c) & \text{Assump} \\
		(2) & \quad (b \land c) \land (\lnot a \lor a) \lor (a \land \lnot b \land c) \lor (a \land b \land \lnot c) & \text{Distrib} \\
		(3) & \quad (b \land c) \lor (a \land \lnot b \land c) \lor (a \land b \land \lnot c) & \text{Compl} \\
		(4) & \quad (c \land (b \lor (a \land \lnot b)))  \lor (a \land b \land \lnot c) & \text{Distrib} \\
		(5) & \quad (c \land (b \lor a \land b \lor \lnot b))  \lor (a \land b \land \lnot c) & \text{Distrib} \\
		(6) & \quad (c \land (b \lor a))  \lor (a \land b \land \lnot c) & \text{Compl} \\
		(7) & \quad (c \land b) \lor (c \land a) \lor (a \land b \land \lnot c) & \text{Distrib} \\
		(8) & \quad (b \land (c \lor (a \land \lnot c)) \lor (c \land a)  & \text{Distrib} \\
		(9) & \quad (b \land (c \lor a)) \lor (c \land a)  & \text{Distrib, Compl} \\
		(10) & \quad  (a \land b) \lor (a \land c) \lor (b \land c) & \text{Distrib, Commut} \\
		(11) & \quad  CO(a, b, c) \iff CO(a, b, c) & \text{Tauto} \\
	\end{align*}
\end{proof}

The $S$ output in a conventional full-adder should result to $True$ when exactly one, or all, of its inputs are $True$. Since our proposed definition of $S$ was not simplified, no further justification is necessary. We will now build upon our previous definitions to specify a standard $N$-bit carry-ripple adder.
\newpage
\noindent \textbf{Definition 2.2} Suppose $a_n$, $a_{n-1}$, $\ldots$, $a_0$, $b_n$, $b_{n-1}$, $\ldots$, $b_0$, and $c$ are propositions for any integer $ n \geq 0$. Then, carry-out and sum outputs of an $N$-bit carry-ripple adder are defined as follows: 
\begin{enumerate}
	\item $ CRACO(a_n, \ldots, a_0, b_n, \ldots, b_0, c) :\equiv CO(a_n, b_n, CO(\ldots, CO(a_0, b_0, c))\ldots)$
	\item $ CRAS(a_n, \ldots, a_0, b_n, \ldots, b_0, c) :\equiv S(a_n, b_n, CRACO(a_{n-1}, \ldots, a_0, b_{n-1}, \ldots, b_0, c)) $
\end{enumerate}

This definition highlights the recursive nature of \( CRACO \) and, by extension, \( CRAS \). This recursive structure arises because the output of each full-adder in a carry-ripple configuration depends on the carry-out of its preceding full-adders. With the essential building blocks defined, we can now delve into the details of our carry-look-ahead adder.

\section{Carry-Look-Ahead Adder}
Carry-look-ahead adders reduce the delays inherent in traditional carry-ripple configurations. They accomplish this by pre-calculating the carry-out dependencies. However, due to their complexity and size, we will focus only on  a 2-bit design, effectively halving our adder's state count.

\noindent \textbf{Definition 3.1} Suppose $a_1$, $a_0$, $b_1$, $b_0$, and $c$ are propositions. Then, the first sum, second sum, and carry-out outputs for our 2-bit carry-look-ahead adder are defined as follows: 
\begin{enumerate}
	\item 
	$ CLAS_0(a_0, b_0, c) :\equiv $
	\begin{align*}  
	&(a_0 \land b_0 \land c) \lor 
	   (a_0 \land \lnot b_0 \land \lnot c) \lor 
	   (\lnot a_0 \land b_0 \land \lnot c) \lor
	   (\lnot a_0 \land \lnot b_0 \land c)
	\end{align*}
	
 	\item
 	$ CLAS_1(a_1, a_0, b_1, b_0, c) :\equiv $
 	\begin{align*}   
	& (a_1 \land a_0 \land b_1 \land b_0)  \lor  && \text{ \tiny (1)} \\
	& (a_1 \land a_0 \land b_1 \land c) \lor && \text{ \tiny (2)} \\ 
	& (a_1 \land b_1 \land b_0 \land c) \lor  && \text{ \tiny (3)} \\
	& (a_1 \land \lnot a_0 \land \lnot b_1 \land \lnot b_0) \lor  && \text{ \tiny (4)} \\
	& (a_1 \land \lnot a_0 \land \lnot b_1 \land \lnot c) \lor  && \text{ \tiny (5)} \\
	& (a_1 \land \lnot b_1 \land \lnot  b_0 \land \lnot c) \lor  && \text{ \tiny (6)} \\
	& (\lnot a_1 \land a_0 \land \lnot b_1 \land b_0) \lor  && \text{ \tiny (7)} \\
	& (\lnot a_1 \land a_0 \land \lnot b_1 \land c) \lor  && \text{ \tiny (8)} \\
	& (\lnot a_1 \land b_1 \land \lnot b_0 \land \lnot c) \lor  && \text{ \tiny (9)} \\
	& (\lnot a_1 \land \lnot a_0 \land b_1 \land \lnot b_0) \lor && \text{ \tiny (10)} \\
	& (\lnot a_1 \land \lnot a_0 \land b_1 \lnot c) \lor  && \text{ \tiny (11)} \\
	& (\lnot a_1 \land \lnot b_1 \land b_0 \land c) && \text{ \tiny (12)}
	\end{align*}
\newpage
	\item 
	$ CLACO(a_1, a_0, b_1, b_0, c) :\equiv $
	\begin{align*} 
	 & (a_1 \land a_0 \land b_0) \lor
	   	 (a_1 \land a_0 \land c) \lor \\
	 & (a_1 \land b_0 \land c) \lor 
	 	 (a_1 \land b_1) \lor \\
	 &  (a_0 \land b_1 \land c) \lor 
	     (a_0 \land b_1 \land b_0) \lor \\
	 & (b_1 \land b_0 \land c) 
	\end{align*}
	   
\end{enumerate}

\noindent \textbf{Lemma 3.1}  $ (\forall a, b, c \in \{T, F\}) \: CLAS_0(a, b, c) \iff S(a, b, c)  $ 
\begin{proof}
	\begin{align*}
	(\lnot a \land \lnot b \land c) \lor (\lnot a \land b \land \lnot c) \lor 
	(a \land \lnot b \land \lnot c) \lor (a \land b \land c) 
	\\ \iff (\lnot a \land \lnot b \land c) \lor 
	(\lnot a \land b \land \lnot c) \lor 
	(a \land \lnot b \land \lnot c) \lor (a \land b \land c) \\
	& \text{Tauto}
	\end{align*}
\end{proof}

\noindent \textbf{Lemma 3.2}  $ (\forall a_1, a_0, b_1, b_0, c \in \{T, F\}) \; CLAS_1(a_1, a_0, b_1, b_0, c) \iff S(a_1, b_1, CO(a_0, b_0, c))  $ 

\begin{proof}
	
	Given the complex structure of $CLAS_1$, we will approach the proof in more manageable steps. By expanding the formula $ S(a_1, b_1, CO(a_0, b_0, c)) $, we aim to demonstrate a bijective relationship: each individual disjunction in  $ S(a_1, b_1, CO(a_0, b_0, c)) $ corresponds precisely to a unique disjunction in $ CLAS_1(a_1, a_0, b_1, b_0, c) $, and vice versa. The labels in the $ CLAS_1 $ definition will provide a clear reference for this correspondence.
	
	\begin{align*}
		S(a_1, b_1, CO(a_0, b_0, c)) = \\ 
		& (a_1 \land b_1 \land CO(a_0, b_0, c)) \lor && \text{\tiny (1)} \\ 
		& (a_1 \land \lnot b_1 \land \lnot CO(a_0, b_0, c)) \lor && \text{\tiny (2)} \\ 
		& (\lnot a_1 \land b_1 \land \lnot CO(a_0, b_0, c)) \lor && \text{\tiny (3)} \\
		& (\lnot a_1 \land \lnot b_1 \land CO(a_0, b_0, c))  && \text{\tiny (4)} \\ 
		&& \text{Assump}
	\end{align*}
	
	\textbf{Subproof 1:}  Expanding disjunction (1)  from $S(a_1, b_1, CO(a_0, b_0, c))$:
	
	\begin{align*}
		(1)  & \quad (a_1 \land b_1 \land (a_0 \land b_0) \lor (a_0 \land c) \lor (b_0 \land c) ) \\
		(2)  & \quad  (a_1 \land a_0 \land b_1   \land b_0) \lor \\
			   & \quad (a_1 \land a_0 \land b_1   \land c) \lor \\
			   & \quad (a_1 \land b_1  \land b_0 \land c)  \\
			   && \text{Distrib} \\	
			   \intertext{The resulting three  disjunctions correspond to (1), (2) and (3) in $CLAS_1$}
	\end{align*}
	
	\textbf{Subproof 2:} Statement or claim of the second subproof.
	
	Proof of the second subproof...
	
	... continue the main proof using results from the subproofs.
	
\end{proof}

\end{document}